import { LuaLexer } from './LuaLexer';
import { LuaParser } from './LuaParser';
import { LuraphVM } from './LuraphVM';
import { LuacGenerator } from './LuacGenerator';
import { ProgramNode } from './types/ASTNodes';
import { DeobfuscationContext, VMProto, VMInstruction, LuaOpcode } from './types/VMInstructions';

export interface DeobfuscationProgress {
  step: string;
  progress: number;
  details?: string;
}

export interface DeobfuscationResult {
  success: boolean;
  deobfuscatedCode?: string;
  luacBytecode?: Uint8Array;
  error?: string;
  statistics?: {
    originalSize: number;
    deobfuscatedSize: number;
    handlersFound: number;
    constantsDecrypted: number;
    instructionsReconstructed: number;
  };
}

export class LuraphDeobfuscator {
  private lexer: LuaLexer;
  private parser: LuaParser;
  private vm: LuraphVM;
  private generator: LuacGenerator;
  
  private onProgress?: (progress: DeobfuscationProgress) => void;

  constructor(onProgress?: (progress: DeobfuscationProgress) => void) {
    this.lexer = new LuaLexer('');
    this.parser = new LuaParser([]);
    this.vm = new LuraphVM();
    this.generator = new LuacGenerator();
    this.onProgress = onProgress;
  }

  public async deobfuscate(luraphScript: string): Promise<DeobfuscationResult> {
    try {
      const originalSize = luraphScript.length;
      let step = 0;
      const totalSteps = 8;

      // Step 1: Lexical Analysis
      this.reportProgress(++step, totalSteps, 'Parsing Lua file...', 'Tokenizing source code');
      this.lexer = new LuaLexer(luraphScript);
      const tokens = this.lexer.tokenize();

      if (tokens.length === 0) {
        throw new Error('Failed to tokenize input - invalid Lua syntax');
      }

      // Step 2: Syntax Analysis
      this.reportProgress(++step, totalSteps, 'Building abstract syntax tree...', `Found ${tokens.length} tokens`);
      this.parser = new LuaParser(tokens);
      const ast = this.parser.parse();

      // Step 3: Luraph Detection
      this.reportProgress(++step, totalSteps, 'Detecting VM handlers...', 'Analyzing obfuscation patterns');
      if (!this.vm.isValidLuraphScript(ast)) {
        throw new Error('Input does not appear to be a valid Luraph obfuscated script');
      }

      // Step 4: VM Analysis
      this.reportProgress(++step, totalSteps, 'Finding encryption information...', 'Extracting VM context');
      const context = this.vm.analyzeAST(ast);
      
      const handlersFound = context.vmContext.handlers.size;
      if (handlersFound === 0) {
        throw new Error('No VM handlers found - script may use unsupported Luraph version');
      }

      // Step 5: Bytecode Extraction
      this.reportProgress(++step, totalSteps, 'Decrypting bytecode...', `Processing ${handlersFound} handlers`);
      const proto = await this.extractBytecode(context);

      // Step 6: Optimization
      this.reportProgress(++step, totalSteps, 'Removing antidecompiler tricks...', 'Cleaning up bytecode');
      this.optimizeBytecode(proto);

      // Step 7: Code Generation
      this.reportProgress(++step, totalSteps, 'Optimizing bytecode...', 'Finalizing instruction sequence');
      const luacBytecode = this.generator.generateLuac(proto);

      if (!this.generator.validateLuac(luacBytecode)) {
        throw new Error('Generated bytecode validation failed');
      }

      // Step 8: Finalization
      this.reportProgress(++step, totalSteps, 'Generating output file...', 'Deobfuscation completed');
      
      const deobfuscatedCode = this.generateReadableCode(proto);
      
      return {
        success: true,
        deobfuscatedCode,
        luacBytecode,
        statistics: {
          originalSize,
          deobfuscatedSize: deobfuscatedCode.length,
          handlersFound: context.vmContext.handlers.size,
          constantsDecrypted: context.decryptedConstants.length,
          instructionsReconstructed: proto.instructions.length
        }
      };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    }
  }

  private async extractBytecode(context: DeobfuscationContext): Promise<VMProto> {
    const proto: VMProto = {
      instructions: [],
      constants: context.decryptedConstants,
      upvalues: [],
      protos: [],
      source: '@deobfuscated.lua',
      lineDefined: 0,
      lastLineDefined: 0,
      numParams: 0,
      isVararg: false,
      maxStackSize: 0
    };

    // Convert VM handlers to Lua instructions
    const handlerArray = Array.from(context.vmContext.handlers.values())
      .sort((a, b) => a.index - b.index);

    for (const handler of handlerArray) {
      const instruction: VMInstruction = {
        opcode: handler.opcode,
        a: 0,
        b: 0,
        c: 0,
        line: handler.index
      };

      // Extract operands from handler (simplified)
      const operands = this.extractOperands(handler);
      if (operands.length >= 1) instruction.a = operands[0];
      if (operands.length >= 2) instruction.b = operands[1];
      if (operands.length >= 3) instruction.c = operands[2];

      proto.instructions.push(instruction);
    }

    // Calculate max stack size
    proto.maxStackSize = this.calculateStackSize(proto.instructions);

    return proto;
  }

  private extractOperands(handler: any): number[] {
    // Extract operands from the handler code
    // This is a simplified version - real implementation would parse the handler AST
    const operands: number[] = [];
    
    const code = handler.decrypted || handler.handler;
    const registerMatches = code.match(/R\[(\d+)\]/g);
    
    if (registerMatches) {
      for (const match of registerMatches.slice(0, 3)) {
        const num = match.match(/\d+/);
        if (num) {
          operands.push(parseInt(num[0]));
        }
      }
    }

    // Fill with defaults if not enough operands
    while (operands.length < 3) {
      operands.push(0);
    }

    return operands;
  }

  private optimizeBytecode(proto: VMProto): void {
    // Remove redundant instructions
    proto.instructions = this.removeRedundantInstructions(proto.instructions);
    
    // Optimize constant loading
    this.optimizeConstants(proto);
    
    // Remove dead code
    this.removeDeadCode(proto);
  }

  private removeRedundantInstructions(instructions: VMInstruction[]): VMInstruction[] {
    const optimized: VMInstruction[] = [];
    
    for (let i = 0; i < instructions.length; i++) {
      const current = instructions[i];
      const next = instructions[i + 1];
      
      // Remove redundant MOVE instructions (MOVE A A)
      if (current.opcode === LuaOpcode.MOVE && current.a === current.b) {
        continue;
      }
      
      // Remove LOADK followed by unused register
      if (current.opcode === LuaOpcode.LOADK && next && 
          next.opcode === LuaOpcode.LOADK && next.a === current.a) {
        continue;
      }
      
      optimized.push(current);
    }
    
    return optimized;
  }

  private optimizeConstants(proto: VMProto): void {
    // Remove duplicate constants
    const uniqueConstants = new Map();
    const constantMapping = new Map();
    
    proto.constants.forEach((constant, index) => {
      const key = `${constant.type}:${constant.value}`;
      if (uniqueConstants.has(key)) {
        constantMapping.set(index, uniqueConstants.get(key));
      } else {
        const newIndex = uniqueConstants.size;
        uniqueConstants.set(key, newIndex);
        constantMapping.set(index, newIndex);
      }
    });

    // Update constant references in instructions
    proto.instructions.forEach(instruction => {
      if (instruction.opcode === LuaOpcode.LOADK && instruction.bx !== undefined) {
        instruction.bx = constantMapping.get(instruction.bx) || instruction.bx;
      }
    });

    // Rebuild constants array
    proto.constants = Array.from(uniqueConstants.keys()).map((key, index) => {
      const [type, value] = key.split(':');
      return {
        type: type as any,
        value: type === 'number' ? parseFloat(value) : value,
        index
      };
    });
  }

  private removeDeadCode(proto: VMProto): void {
    // Simple dead code elimination
    const reachable = new Set<number>();
    const worklist = [0]; // Start from first instruction
    
    while (worklist.length > 0) {
      const pc = worklist.pop()!;
      if (reachable.has(pc) || pc >= proto.instructions.length) continue;
      
      reachable.add(pc);
      const instruction = proto.instructions[pc];
      
      // Add successors
      switch (instruction.opcode) {
        case LuaOpcode.JMP:
          if (instruction.sbx !== undefined) {
            worklist.push(pc + 1 + instruction.sbx);
          }
          break;
        case LuaOpcode.RETURN:
          // No successors
          break;
        default:
          worklist.push(pc + 1);
          break;
      }
    }
    
    // Filter out unreachable instructions
    proto.instructions = proto.instructions.filter((_, index) => reachable.has(index));
  }

  private calculateStackSize(instructions: VMInstruction[]): number {
    let maxStack = 0;
    let currentStack = 0;
    
    for (const instruction of instructions) {
      switch (instruction.opcode) {
        case LuaOpcode.LOADK:
        case LuaOpcode.LOADBOOL:
        case LuaOpcode.LOADNIL:
          currentStack = Math.max(currentStack, instruction.a + 1);
          break;
        case LuaOpcode.CALL:
          if (instruction.b > 0) {
            currentStack = Math.max(currentStack, instruction.a + instruction.b);
          }
          if (instruction.c > 0) {
            currentStack = Math.max(currentStack, instruction.a + instruction.c - 1);
          }
          break;
        case LuaOpcode.NEWTABLE:
          currentStack = Math.max(currentStack, instruction.a + 1);
          break;
      }
      
      maxStack = Math.max(maxStack, currentStack);
    }
    
    return Math.max(maxStack, 2); // Minimum stack size
  }

  private generateReadableCode(proto: VMProto): string {
    // Generate readable Lua code from the prototype
    const lines: string[] = [];
    lines.push('-- Deobfuscated Lua Script');
    lines.push('-- Original script was obfuscated with Luraph');
    lines.push('-- Deobfuscation completed successfully');
    lines.push('');

    // Add constants as comments
    if (proto.constants.length > 0) {
      lines.push('-- Constants:');
      proto.constants.forEach((constant, index) => {
        lines.push(`-- K[${index}] = ${JSON.stringify(constant.value)} (${constant.type})`);
      });
      lines.push('');
    }

    // Convert instructions to readable pseudocode
    lines.push('-- Reconstructed bytecode:');
    proto.instructions.forEach((instruction, index) => {
      const opcodeName = LuaOpcode[instruction.opcode] || 'UNKNOWN';
      const line = `-- ${index.toString().padStart(3, '0')}: ${opcodeName} ${instruction.a} ${instruction.b || 0} ${instruction.c || 0}`;
      lines.push(line);
    });

    lines.push('');
    lines.push('-- This is a simplified representation of the deobfuscated code.');
    lines.push('-- For full decompilation, use a Lua decompiler like unluac on the generated .luac file.');

    return lines.join('\n');
  }

  private reportProgress(step: number, totalSteps: number, stepName: string, details?: string): void {
    if (this.onProgress) {
      this.onProgress({
        step: stepName,
        progress: (step / totalSteps) * 100,
        details
      });
    }
  }

  // Static method for quick deobfuscation
  public static async deobfuscateScript(
    script: string, 
    onProgress?: (progress: DeobfuscationProgress) => void
  ): Promise<DeobfuscationResult> {
    const deobfuscator = new LuraphDeobfuscator(onProgress);
    return await deobfuscator.deobfuscate(script);
  }
}