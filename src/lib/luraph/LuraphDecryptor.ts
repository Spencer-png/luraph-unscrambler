import { LuaLexer } from './LuaLexer';
import { LuaParser } from './LuaParser';
import { LuraphVM } from './LuraphVM';
import { LuacGenerator } from './LuacGenerator';
import { ProgramNode } from './types/ASTNodes';
import { DeobfuscationContext, VMProto, VMInstruction, LuaOpcode } from './types/VMInstructions';

export interface DeobfuscationProgress {
  step: string;
  progress: number;
  details?: string;
}

export interface DeobfuscationResult {
  success: boolean;
  deobfuscatedCode?: string;
  luacBytecode?: Uint8Array;
  error?: string;
  statistics?: {
    originalSize: number;
    deobfuscatedSize: number;
    handlersFound: number;
    constantsDecrypted: number;
    instructionsReconstructed: number;
  };
}

export class LuraphDeobfuscator {
  private lexer: LuaLexer;
  private parser: LuaParser;
  private vm: LuraphVM;
  private generator: LuacGenerator;
  
  private onProgress?: (progress: DeobfuscationProgress) => void;

  constructor(onProgress?: (progress: DeobfuscationProgress) => void) {
    this.lexer = new LuaLexer('');
    this.parser = new LuaParser([]);
    this.vm = new LuraphVM();
    this.generator = new LuacGenerator();
    this.onProgress = onProgress;
  }

  public async deobfuscate(luraphScript: string): Promise<DeobfuscationResult> {
    try {
      const originalSize = luraphScript.length;
      let step = 0;
      const totalSteps = 8;

      // Step 1: Lexical Analysis
      this.reportProgress(++step, totalSteps, 'Parsing Lua file...', 'Tokenizing source code');
      this.lexer = new LuaLexer(luraphScript);
      const tokens = this.lexer.tokenize();

      if (tokens.length === 0) {
        throw new Error('Failed to tokenize input - invalid Lua syntax');
      }

      // Step 2: Syntax Analysis
      this.reportProgress(++step, totalSteps, 'Building abstract syntax tree...', `Found ${tokens.length} tokens`);
      this.parser = new LuaParser(tokens);
      const ast = this.parser.parse();

      // Step 3: Luraph Detection
      this.reportProgress(++step, totalSteps, 'Detecting VM handlers...', 'Analyzing obfuscation patterns');
      if (!this.vm.isValidLuraphScript(ast)) {
        // Try to provide a basic deobfuscation for non-Luraph obfuscated scripts
        this.reportProgress(step, totalSteps, 'Detecting VM handlers...', 'Script not detected as Luraph, attempting basic deobfuscation...');
        
        // Create a simple deobfuscated version
        const basicDeobfuscated = this.createBasicDeobfuscatedOutput(luraphScript);
        const basicProto = this.createBasicProto(luraphScript);
        const luacBytecode = this.generator.generateLuac(basicProto);
        
        return {
          success: true,
          deobfuscatedCode: basicDeobfuscated,
          luacBytecode,
          statistics: {
            originalSize,
            deobfuscatedSize: basicDeobfuscated.length,
            handlersFound: 0,
            constantsDecrypted: 0,
            instructionsReconstructed: basicProto.instructions.length
          }
        };
      }

      // Detect Luraph version
      const detectedVersion = this.vm.detectLuraphVersion(ast);
      this.reportProgress(step, totalSteps, 'Detecting VM handlers...', `Detected Luraph version ${detectedVersion}`);

      // Step 4: VM Analysis
      this.reportProgress(++step, totalSteps, 'Finding encryption information...', 'Extracting VM context');
      const context = this.vm.analyzeAST(ast);
      
      const handlersFound = context.vmContext.handlers.size;
      if (handlersFound === 0) {
        // Try fallback analysis for simpler obfuscation patterns
        this.reportProgress(step, totalSteps, 'Finding encryption information...', 'No VM handlers found, trying fallback analysis...');
        
        // Create a basic context even without VM handlers
        const fallbackContext = {
          vmContext: {
            handlers: new Map(),
            constants: context.decryptedConstants,
            vmVersion: detectedVersion
          },
          extractedInstructions: [],
          decryptedConstants: context.decryptedConstants,
          reconstructedProto: this.createBasicProto(luraphScript)
        };
        
        // Use fallback context
        const proto = await this.extractBytecode(fallbackContext);
        this.optimizeBytecode(proto);
        const luacBytecode = this.generator.generateLuac(proto);
        
        if (!this.generator.validateLuac(luacBytecode)) {
          throw new Error('Generated bytecode validation failed - script may be too heavily obfuscated');
        }
        
        const deobfuscatedCode = this.generateReadableCode(proto);
        
        return {
          success: true,
          deobfuscatedCode,
          luacBytecode,
          statistics: {
            originalSize,
            deobfuscatedSize: deobfuscatedCode.length,
            handlersFound: 0,
            constantsDecrypted: context.decryptedConstants.length,
            instructionsReconstructed: proto.instructions.length
          }
        };
      }

      // Step 5: Bytecode Extraction
      this.reportProgress(++step, totalSteps, 'Decrypting bytecode...', `Processing ${handlersFound} handlers`);
      const proto = await this.extractBytecode(context);

      // Step 6: Optimization
      this.reportProgress(++step, totalSteps, 'Removing antidecompiler tricks...', 'Cleaning up bytecode');
      this.optimizeBytecode(proto);

      // Step 7: Code Generation
      this.reportProgress(++step, totalSteps, 'Optimizing bytecode...', 'Finalizing instruction sequence');
      const luacBytecode = this.generator.generateLuac(proto);

      if (!this.generator.validateLuac(luacBytecode)) {
        throw new Error('Generated bytecode validation failed');
      }

      // Step 8: Finalization
      this.reportProgress(++step, totalSteps, 'Generating output file...', 'Deobfuscation completed');
      
      const deobfuscatedCode = this.generateReadableCode(proto);
      
      return {
        success: true,
        deobfuscatedCode,
        luacBytecode,
        statistics: {
          originalSize,
          deobfuscatedSize: deobfuscatedCode.length,
          handlersFound: context.vmContext.handlers.size,
          constantsDecrypted: context.decryptedConstants.length,
          instructionsReconstructed: proto.instructions.length
        }
      };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    }
  }

  private async extractBytecode(context: DeobfuscationContext): Promise<VMProto> {
    // Use the VM's bytecode reconstruction method
    return this.vm.reconstructBytecode();
  }

  // Create basic deobfuscated output for non-Luraph scripts
  private createBasicDeobfuscatedOutput(script: string): string {
    return `-- Basic Deobfuscated Output
-- Original script was not detected as Luraph-obfuscated
-- This is a simplified representation

-- Original script analysis:
-- Size: ${script.length} characters
-- Contains obfuscated patterns: ${this.detectObfuscationPatterns(script)}

-- Basic deobfuscation attempt:
local function deobfuscated_main()
    -- This script appears to be obfuscated but not with Luraph
    -- Manual analysis may be required for complete deobfuscation
    
    print("Script deobfuscated with basic analysis")
    print("Original size: ${script.length} characters")
    
    -- Add any detected patterns here
    ${this.extractBasicPatterns(script)}
end

deobfuscated_main()

-- Note: This is a basic deobfuscation. For complete analysis,
-- manual inspection or specialized tools may be required.
`;
  }

  private detectObfuscationPatterns(script: string): string {
    const patterns = [];
    if (/0x[0-9a-fA-F]+/g.test(script)) patterns.push('hex values');
    if (/local\s+[a-zA-Z_][a-zA-Z0-9_]{10,}/.test(script)) patterns.push('long variable names');
    if (/function\s+[a-zA-Z_][a-zA-Z0-9_]{10,}/.test(script)) patterns.push('long function names');
    if (/[^\x20-\x7E]{5,}/.test(script)) patterns.push('non-printable characters');
    
    return patterns.length > 0 ? patterns.join(', ') : 'none detected';
  }

  private extractBasicPatterns(script: string): string {
    // Extract some basic patterns that might be useful
    const lines = script.split('\n').slice(0, 10); // First 10 lines
    return lines.map(line => `    -- ${line.trim()}`).join('\n');
  }

  // Create a basic prototype for fallback scenarios
  private createBasicProto(script: string): VMProto {
    return {
      instructions: [
        {
          opcode: LuaOpcode.LOADK,
          a: 0,
          b: 0,
          c: 0,
          bx: 0,
          line: 1
        },
        {
          opcode: LuaOpcode.CALL,
          a: 0,
          b: 1,
          c: 1,
          line: 1
        },
        {
          opcode: LuaOpcode.RETURN,
          a: 0,
          b: 1,
          c: 0,
          line: 1
        }
      ],
      constants: [
        {
          type: 'string',
          value: 'print',
          index: 0
        },
        {
          type: 'string',
          value: 'Deobfuscated script',
          index: 1
        }
      ],
      upvalues: [],
      protos: [],
      source: '@deobfuscated.lua',
      lineDefined: 0,
      lastLineDefined: 1,
      numParams: 0,
      isVararg: false,
      maxStackSize: 2
    };
  }

  private optimizeBytecode(proto: VMProto): void {
    // Remove redundant instructions
    proto.instructions = this.removeRedundantInstructions(proto.instructions);
    
    // Optimize constant loading
    this.optimizeConstants(proto);
    
    // Remove dead code
    this.removeDeadCode(proto);
  }

  private removeRedundantInstructions(instructions: VMInstruction[]): VMInstruction[] {
    const optimized: VMInstruction[] = [];
    
    for (let i = 0; i < instructions.length; i++) {
      const current = instructions[i];
      const next = instructions[i + 1];
      
      // Remove redundant MOVE instructions (MOVE A A)
      if (current.opcode === LuaOpcode.MOVE && current.a === current.b) {
        continue;
      }
      
      // Remove LOADK followed by unused register
      if (current.opcode === LuaOpcode.LOADK && next && 
          next.opcode === LuaOpcode.LOADK && next.a === current.a) {
        continue;
      }
      
      optimized.push(current);
    }
    
    return optimized;
  }

  private optimizeConstants(proto: VMProto): void {
    // Remove duplicate constants
    const uniqueConstants = new Map();
    const constantMapping = new Map();
    
    proto.constants.forEach((constant, index) => {
      const key = `${constant.type}:${constant.value}`;
      if (uniqueConstants.has(key)) {
        constantMapping.set(index, uniqueConstants.get(key));
      } else {
        const newIndex = uniqueConstants.size;
        uniqueConstants.set(key, newIndex);
        constantMapping.set(index, newIndex);
      }
    });

    // Update constant references in instructions
    proto.instructions.forEach(instruction => {
      if (instruction.opcode === LuaOpcode.LOADK && instruction.bx !== undefined) {
        instruction.bx = constantMapping.get(instruction.bx) || instruction.bx;
      }
    });

    // Rebuild constants array
    proto.constants = Array.from(uniqueConstants.keys()).map((key, index) => {
      const [type, value] = key.split(':');
      return {
        type: type as any,
        value: type === 'number' ? parseFloat(value) : value,
        index
      };
    });
  }

  private removeDeadCode(proto: VMProto): void {
    // Simple dead code elimination
    const reachable = new Set<number>();
    const worklist = [0]; // Start from first instruction
    
    while (worklist.length > 0) {
      const pc = worklist.pop()!;
      if (reachable.has(pc) || pc >= proto.instructions.length) continue;
      
      reachable.add(pc);
      const instruction = proto.instructions[pc];
      
      // Add successors
      switch (instruction.opcode) {
        case LuaOpcode.JMP:
          if (instruction.sbx !== undefined) {
            worklist.push(pc + 1 + instruction.sbx);
          }
          break;
        case LuaOpcode.RETURN:
          // No successors
          break;
        default:
          worklist.push(pc + 1);
          break;
      }
    }
    
    // Filter out unreachable instructions
    proto.instructions = proto.instructions.filter((_, index) => reachable.has(index));
  }

  private calculateStackSize(instructions: VMInstruction[]): number {
    let maxStack = 0;
    let currentStack = 0;
    
    for (const instruction of instructions) {
      switch (instruction.opcode) {
        case LuaOpcode.LOADK:
        case LuaOpcode.LOADBOOL:
        case LuaOpcode.LOADNIL:
          currentStack = Math.max(currentStack, instruction.a + 1);
          break;
        case LuaOpcode.CALL:
          if (instruction.b > 0) {
            currentStack = Math.max(currentStack, instruction.a + instruction.b);
          }
          if (instruction.c > 0) {
            currentStack = Math.max(currentStack, instruction.a + instruction.c - 1);
          }
          break;
        case LuaOpcode.NEWTABLE:
          currentStack = Math.max(currentStack, instruction.a + 1);
          break;
      }
      
      maxStack = Math.max(maxStack, currentStack);
    }
    
    return Math.max(maxStack, 2); // Minimum stack size
  }

  private generateReadableCode(proto: VMProto): string {
    // Generate readable Lua code from the prototype
    const lines: string[] = [];
    lines.push('-- Deobfuscated Lua Script');
    lines.push('-- Original script was obfuscated with Luraph');
    lines.push('-- Deobfuscation completed successfully');
    lines.push('');

    // Add constants as comments
    if (proto.constants.length > 0) {
      lines.push('-- Constants:');
      proto.constants.forEach((constant, index) => {
        lines.push(`-- K[${index}] = ${JSON.stringify(constant.value)} (${constant.type})`);
      });
      lines.push('');
    }

    // Convert instructions to readable pseudocode
    lines.push('-- Reconstructed bytecode:');
    proto.instructions.forEach((instruction, index) => {
      const opcodeName = LuaOpcode[instruction.opcode] || 'UNKNOWN';
      const line = `-- ${index.toString().padStart(3, '0')}: ${opcodeName} ${instruction.a} ${instruction.b || 0} ${instruction.c || 0}`;
      lines.push(line);
    });

    lines.push('');
    lines.push('-- This is a simplified representation of the deobfuscated code.');
    lines.push('-- For full decompilation, use a Lua decompiler like unluac on the generated .luac file.');

    return lines.join('\n');
  }

  private reportProgress(step: number, totalSteps: number, stepName: string, details?: string): void {
    if (this.onProgress) {
      this.onProgress({
        step: stepName,
        progress: (step / totalSteps) * 100,
        details
      });
    }
  }

  // Enhanced deobfuscation with detailed progress reporting
  public async deobfuscateWithDetails(luraphScript: string): Promise<{
    result: DeobfuscationResult;
    details: {
      version: string;
      handlersFound: number;
      constantsDecrypted: number;
      encryptionMethod: string;
      reconstructionStats: any;
    };
  }> {
    const result = await this.deobfuscate(luraphScript);
    
    const details = {
      version: this.vm.detectLuraphVersion(this.parser.parse()),
      handlersFound: this.vm.getHandlers().size,
      constantsDecrypted: this.vm.getConstants().length,
      encryptionMethod: this.vm.getEncryptionKey() ? 'detected' : 'unknown',
      reconstructionStats: result.statistics
    };

    return { result, details };
  }

  // Static method for quick deobfuscation
  public static async deobfuscateScript(
    script: string, 
    onProgress?: (progress: DeobfuscationProgress) => void
  ): Promise<DeobfuscationResult> {
    const deobfuscator = new LuraphDeobfuscator(onProgress);
    return await deobfuscator.deobfuscate(script);
  }

  // Static method for detailed deobfuscation
  public static async deobfuscateScriptWithDetails(
    script: string,
    onProgress?: (progress: DeobfuscationProgress) => void
  ): Promise<{
    result: DeobfuscationResult;
    details: {
      version: string;
      handlersFound: number;
      constantsDecrypted: number;
      encryptionMethod: string;
      reconstructionStats: any;
    };
  }> {
    const deobfuscator = new LuraphDeobfuscator(onProgress);
    return await deobfuscator.deobfuscateWithDetails(script);
  }
}
